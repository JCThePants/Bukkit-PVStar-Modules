apply plugin: 'java'


defaultTasks 'clean', 'build'

// Minimum Java Version
sourceCompatibility = 1.7
targetCompatibility = 1.7

// evaluate settings from module projects first
project.evaluationDependsOnChildren()



if (hasProperty("teamcity"))
    def teamcity = teamcity

// module project script
subprojects {


    // always download the latest version:
    def snapshotDepends = [
            'com.jcwhatever.bukkit:NucleusFramework:0.0-SNAPSHOT',
            'com.jcwhatever.bukkit:PV-StarAPI:0.0-SNAPSHOT',
    ]

    apply plugin: 'java'

    defaultTasks 'clean', 'build'

    // Minimum Java Version
    sourceCompatibility = 1.7
    targetCompatibility = 1.7


    // Set version number
    if (rootProject.hasProperty("teamcity")) {

        version = majorVersion + '.' + teamcity["build.number"] + '.git-' + teamcity["build.vcs.number"]

        if (buildBy == null) {
            buildBy = teamcity["build.triggeredBy.username"]

            if (!buildBy) {
                buildBy = teamcity["build.triggeredBy"]
            }

            if (!buildBy) {
                buildBy = teamcity["agent.name"]
            }
        }

    }else {
        version = majorVersion + '.000.git-unknown'
    }

    if (buildBy == null) {
        buildBy = System.properties['user.name']
    }

    // Add provided configuration to prevent dependencies
    // from being included in the jar
    configurations {
        provided
        all {
            // check for updates every build
            resolutionStrategy.cacheChangingModulesFor 30, 'seconds'
        }
    }

    sourceSets {

        main {
            compileClasspath += configurations.provided
            runtimeClasspath += configurations.provided

            java {
                srcDir 'src'
            }
        }

        test {
            compileClasspath += configurations.provided
            runtimeClasspath += configurations.provided
        }
    }

    repositories {
        mavenCentral()

        for (repo in mavenRepositories) {
            maven {
                url repo
            }
        }
    }

    // Add dependencies
    dependencies {

        if (compileDependsFiles) {
            compile files(compileDependsFiles)
        }

        if (providedDependsFiles) {
            provided files(providedDependsFiles)
        }

        if (compileDepends) {
            for (depend in compileDepends) {
                compile(depend) {
                    changing = changing || (snapshotDepends && snapshotDepends.contains(depend))
                }
            }
        }

        if (providedDepends) {
            for (depend in providedDepends) {
                provided(depend) {
                    changing = changing || (snapshotDepends && snapshotDepends.contains(depend))
                }
            }
        }
    }

    // Jar file output
    jar {

        archiveName = projectName + '.jar'

        from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }

        if (includeFiles) {
            from includeFiles
        }

        manifest {
            attributes("Built-By": buildBy,
                    "Created-By": System.properties['java.vm.version'] + " (" + System.properties['java.vm.vendor'] + ")",
                    "Implementation-Title": projectName,
                    "Implementation-Version": version)
        }
    }

}

copy {
    allprojects {
        from project.getName() + '/build/libs'
    }
    into "artifacts"
}



